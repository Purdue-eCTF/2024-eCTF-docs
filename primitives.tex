\section{Cryptographic Primitives}
\label{sec:crypto-primitives}

In this section, we outline the cryptographic primitives and protocols that will be used to provide data confidentiality, authenticity, and integrity to our protocols. 

\subsection{TRNG}

Randomness is the most fundamental building block in cryptography as it allows secrets (such as the private key) to be generated in an unpredictable manner. The security of cryptographic protocols hence relies heavily on the security of the random number generator that they use.

The ARM TrustZone True Random Number Generator (denoted as TRNG hereafter) \cite{TRNG} will be used as the primary source of randomness at the hardware level. TRNG is known to provide (almost) full entropy bits and complies with the NIST standard for random bit generation \cite{NIST-TRNG}. See the official documentation \cite{TRNG} for more details. When more random numbers are needed at the software level or performance issues related to TRNG arise, a pseudorandom number generator (PRNG) will be used using random numbers generated by TRNG as seeds, which is one of the intended uses of TRNG as the official webpage \cite{TRNG} indicates.   

\subsection{HMAC}

A hash-based message authentication code (HMAC) will be used as a message authentication code (MAC) providing the data integrity for our protocol. HMAC, as the name implies, is a MAC scheme that is primarily based on and relies on the security of the hash function. 

Given a secret key $k$ and message $m$, HMAC can be defined as follows mathematically:
$$
\HMAC(k, m) := H(k_1 \| H(k_2 \| m))
$$
where $k_1 = k \oplus (\texttt{0x36} \cdots \texttt{0x36})$ and $k_2 = k \oplus (\texttt{0x5c}\cdots \texttt{0x5c})$. For security purposes, we will be using SHA-256 for the hash function. The length of $k$ and the byte strings that they are XORed with are then chosen to be 32 bytes. If the user wishes to use the key $k$ of a different length, they may use $H(k)$ instead of $k$ to make it satisfy the length requirement. More details about HMAC can be found in RFC 2104 \cite{rfc2104} where it was first standardized. 

HMAC can be used to provide the authenticity and integrity of the message $m$. Upon receiving the message $m$ and its HMAC $\tau$, the user can compute the HMAC of $m$ using the shared secret key and verify whether it matches the HMAC value $\tau$ that they received along with $m$. This shows whether $\tau$ truly was generated by the owner of the shared secret key or not, and whether $m$ was altered during the course of communication by someone else or not. However, using HMAC alone can make the protocol vulnerable against replay attacks where an eavesdropper seizes a message-MAC pair $(m, \tau)$ and uses it to impersonate the sender. To prevent this, we will be generating nonce which will be used with the message $m$ to generate the MAC value. 

\subsection{ChaCha20}

ChaCha20 is a Salsa20-based stream cipher that is known to be more resilient against timing or caching attacks than other popular private key encryption schemes such as AES \cite{Najm2018ChaCha20}, and is considered one of the most secure encryption schemes against cryptoanalytic attacks currently \cite{Mouha2013Salsa20}. Several experimental results such as \cite{DeStatis2017ChaCha20} show that ChaCha20 is more optimal for embedded systems due to its optimal performance. ChaCha20 also comes with an extension for authenticated encryption (AE), known as ChaCha20-Poly1305, which can be used to provide both confidentiality and authenticity of messages. As message authenticity is the key in this project, ChaCha20 with Poly1305 extension will be used to provide an additional layer of authenticity in our protocol. Due to its complexity, ChaCha20 nor Poly1305 will not be described or explained in this paper unfortunately. Curious readers should feel free to read RFC 8439 \cite{rfc8439} if more details are desired.  

\subsection{Digital Signature}

\jimmy{TODO for Jimmy}

\jimmy{Which DS scheme we are gonna use? EdDSA?}

\jimmy{Find and read papers about its performance and side-channel resilience.}

% \jw{Hash, PRNG, HMAC, Encryption, maybe Digital Signature -- see comments below here in \LaTeX}

% \jimmy{How about we move this section so it comes right after the protocols?}

% \jimmy{I think for protocols we should be as abstract out all crypto parts (e.g., instead of mentioning HMAC, just say MAC) because we should first tell and convince the readers which primitives will be used (e.g., they need to know that we are using MAC first). Then in the crypto section (i.e., this section) we say `We will use HMAC for MAC'. }

% \jw{In typical papers and technical reports, primitives usually comes before proposed design/protocol (``here are the building blocks you need to understand what we did''). For example, tell them what encryption is, what a MAC is, what a random number generator is, etc. I agree we can talk more specifically about instantiations later. ("Implementation" section, where we can bring up build and deployment details too?). I lumped it all into one last year and put it before protocols, but I agree we should put details after.}

% \jimmy{Okay then let's put the primitives here. }

%\subsection{Authenticated Encryption}

 %Authenticated Encryption with Associated Data, or AEAD for short, is a cryptographic primitive which guarantees both confidentiality and also integrity/authenticity for the messages it encrypts.
 %\iflong
 %AEAD allows for the addition of public \textit{associated data} (AD) as input into encryption/decryption, effectively binding the ciphertext to a shared context (often, the ciphertext's packet header). More formally, an
 %\else An \fi AEAD scheme can be defined as follows:

 %\begin{description}
 %   \item[$\mathsf{AEAD}.\enc(K,N,A,P) \to (C,T)$:] Authenticated Encryption (AE) takes as input a symmetric key $K$, a \emph{unique} nonce $N$, public associated data $A$, and plaintext $P$. It outputs its ciphertext $C$ along with an authentication tag $T$ used to verify its authenticity.
 %   \item[$\mathsf{AEAD}.\dec(K,N,A,C,T) \to P$:] Verified Decryption takes as input the symmetric key $K$, the nonce $N$ and associated data $A$ used to encrypt, the ciphertext $C$, and the tag $T$. While decrypting, it uses tag $T$ to verify that $(K,N,A,C)$ was unmodified. It outputs the decrypted plaintext $P$, or error ($\bot$) if the verification check fails.
 %\end{description}

 %We choose to instantiate our AEAD with the authors' implementation of theNIST Lightweight Cryptography winner, A\textsc{scon}-128~\cite{JC:DEMS21}. A\textsc{scon} uses a duplex sponge-based mode of operation. We use the recommended parameters with uniformly random 128-bit key $K$, $r=64$ bit rate (i.e., the block length for processing associated data, plaintext, and ciphertext), and a capacity of $c=256$ bits. The output has $|C| = |P|$ with a 128-bit tag $T$. We choose 128-bit nonces $N$ uniformly randomly.

 %A\textsc{scon}-128 was chosen primarily for its impressive resistance against nonce-misuse even compared to AES-GCM-SIV, small code binaries, and resistance to various side-channel attacks (SCA).
 %\iflong
 %Internally, A\textsc{scon}'s AEAD uses only a 320-bit internal state. For both encryption and decryption it uses a $a=12$ round permutation $p^a$ for initializing the state with key/nonce and finalizing with a tag, and a $b=6$ round permutation $p^b$ for iteratively ``absorbing'' the associated data and input blocks then ``squeezing'' out the output blocks.
 %\else
 %Its permutations use $a=12$ rounds for initialization/finalization and $b=6$ rounds for data processing (i.e., encryption/decryption).
 %\fi
 %See \cite{JC:DEMS21} for more details about how A\textsc{scon} works.

 %\subsection{Cryptographic Hash Functions}

%Cryptographic hash functions are a one-way function which takes an arbitrary-length input and produces a (short) fixed-length output which minimizes the number of potential \emph{collisions} (i.e., two distinct inputs producing the same output) and cannot be efficiently inverted:
%$$H : \{0,1\}^* \to \{0,1\}^\ell$$
%We choose to instantiate our hash function with A\textsc{scon} hash~\cite{JC:DEMS21}, which uses a sponge-based mode of operation. We use the recommended parameters with a rate/block-length of $r=64$ bits, a capacity of $c=256$ bits, and a hash ``digest'' (output) size of $\ell=256$ bits. Its permutations use 12 rounds for both initialization/finalization and data processing.

%A\textsc{scon}-H\textsc{ash} was chosen primarily for its collision resistance (particularly, against identical-prefix attacks) due to the sponge construction, resistance to SCA, and minimal binary size.
%\iflong
%A large proportion shares code with A\textsc{scon}'s AEAD mode as well, which greatly reduces the code binary size.
%\fi
%\newpage

%\subsection{Pseudo-random Number Generators}

%A pseudo-random number generator (PRNG), also known as a deterministic random-bit generator (DRBG), is a function which takes a random and ideally high-entropy \emph{seed} as input to produce a stream of pseudo-random bits which remain unpredictable unless the seed is known.
%\iflong
%With cryptographically-secure PRNGs, one should not be able to infer the seed, internal state between executions, or prior/future inputs \emph{even if an attacker sees the random bits it generates}. PRNGs are especially useful for scenarios such as these, where the operating system or hardware only has access to weak and/or infrequent sources of entropy for generating ``true'' random values, and needs to generate significantly longer ``random-looking'' bitstrings than hardware sources can allow.
%\fi
%More formally, a PRNG can be defined by the following algorithms:

%\begin{description}
%    \item[$\mathsf{PRNG}.\mathsf{init}(s) \to \sigma$:] Given a high-entropy random seed $s$, initialize the internal state $\sigma$.
%    \item[$\mathsf{PRNG}.\mathsf{gen}(\sigma, b, \mathsf{aux}\!=\!\texttt{NULL}) \to (r, \sigma')$:] Given the internal state $\sigma$, \#bits requested $b$, and\\optional auxiliary data $\mathsf{aux}$, update the state and return a $b$-bit pseudo-random $r$.
%    \item[$\mathsf{PRNG}.\mathsf{reseed}(\sigma, e, \mathsf{aux}\!=\!\texttt{NULL}) \to \sigma':$] Given the current internal state $\sigma$, a high-entropy random input $e$, and optional auxiliary data $\mathsf{aux}$, update the state with fresh entropy.
%\end{description}

%\iflong
%There are many ways of constructing PRNGs. A common approach to constructing PRNGs, as defined by NIST SP 800-90A Rev.1~\cite{NIST-DRBG}, is to rely on the security of an underlying cryptographic primitive: for example, using counter-based modes of operation for encryption, hashes, or message authentication codes (MACs) / keyed PRFs. Such constructions are especially useful with limited access to cryptographic libraries or sources of randomness.

%And, as we could not find any cryptographically-secure PRNGs provided by the board's drivers or any other system-level sources of randomness (which most libraries' RNGs often rely on). Many other approaches were deemed too inefficient given the functional constraints of the competition as well, so we chose to use the HMAC/keyed PRF function in the A\textsc{scon} cryptosuite to implement a suitable PRNG. In particular, we chose the HMAC\_DRBG implementation as specified in NIST SP 800-90A since we could not find any SCA-resistant counter-based ciphers to implement CTR\_DRBG with.

%The security of PRNG schemes rely on the security of the primitives used to construct them~\cite{NIST-DRBG} and, in turn, HMACs are less reliant on the collision resistance properties of their underlying hash functions~\cite{NIST-HMAC-MD5}. While the NIST specifications offered such security claims without proofs, HMAC\_DRBG was later formally proven to be secure assuming only that the underlying HMAC acts as a keyed PRF~\cite{WISA:Hirose08}.
%\else
%We implement the HMAC-based DRBG as specified by NIST SP 800-90A Rev.1~\cite{NIST-DRBG} which has been proven secure as long as the underlying HMAC primitive satisfies the properties of a keyed PRF~\cite{WISA:Hirose08}. Furthermore, HMACs are well-known to be less reliant on the collision resistance of their underlying hash functions~\cite{NIST-HMAC-MD5}.
%\fi
%Indeed, the authors' official implementation of A\textsc{scon}
%\iflong
%\footnote{A\textsc{scon} source code: \url{https://github.com/ascon/ascon-c}}
%\fi
%provides a combined HMAC/keyed PRF construction to use.

%See the NIST SP 800-90A specifications for more details on how the PRNG works.

%Regardless of how secure the PRNG algorithm is,
%\iflong
%the randomness of its output relies on the entropy of the seed it was instantiated with, and choices of seed and reseeding policies must be modified as appropriate for the particular device and application using it.
%\else
%it is also important to consider the quality of the entropy sources used to instantiate the seed.
%\fi
%And so, we briefly discuss how we obtained sources of entropy on the board as well.

%\paragraph{Seed generation.}
%\iflong
%Soon after powering on, many hardware-level sources of randomness commonly used for PRNGs are ill-suited for seeding on this microcontroller, either producing obviously non-random values or being easily manipulatable.
%\fi
%One of the most robust sources we could find to create the initial seed on the board was SRAM since, immediately after a power cycle, most memory blocks contain random data prior to initialization, and most blocks remain untouched by the bootloader. We construct the seed by hashing together large blocks of SRAM along with other random data we store on EEPROM as entropy sources. Together, this ensures that the seed will change unpredictably across both power cycles and resets.

%\paragraph{Reseeding policies.} After the board has had time to ``warm up'', we have access to many other sources of entropy. In particular, we incorporate current \texttt{CPUUsageTick} as a source of randomness along with entropy provided by UART packet sends from previous protocol executions, if available. Then, as per NIST recommendations, we hash the entropy inputs and nonce together with the current state of the PRNG to incorporate additional entropy. We deviate slightly from the original specifications, fine-tuning its usage to this specific application by enforcing a reseed after the very first 128-bit random value that's generated. We also chose a significantly more conservative reseed interval of 8192 random values.

%We have vetted the quality of our on-board PRNG implementation using an implementation of the test suites defined in NIST SP 800-22 Rev. 1A~\cite{NIST-PRNG-TESTS}.
%\iflong
%A summary of the test suites' $p$-values are below, where $0.0$ indicates that the test distinguishes the PRNG output from random and $1.0$ indicates that it is indistinguishable:


%\par In the remaining sections, we will discuss at a high-level how each of these primitives are used to implement each PARED protocol, and how this achieves the security requirements.